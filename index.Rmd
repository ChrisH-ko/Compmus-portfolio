---
title: "The Scriabin sonatas"
author: "Chris"
date: "2024-02-21"
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    css: stylesheets/style.css
---

```{r setup, include=FALSE}
remotes::install_github('jaburgoyne/compmus')

library(tidyverse)
library(spotifyr)
library(compmus)
library(cowplot)
library(plotly)
```

```{r corpus, include=FALSE, cache=TRUE}
lettberg <- readRDS(file = "data/playlists/lettberg-playlist.RDS") |> add_audio_analysis()
ashkenazy <- readRDS(file = "data/playlists/ashkenazy-playlist.RDS") |> add_audio_analysis()
alexeev <- readRDS(file = "data/playlists/alexeev-playlist.RDS") |> add_audio_analysis()
zhukov <- readRDS(file = "data/playlists/zhukov-playlist.RDS") |> add_audio_analysis()

pianists <- list(lettberg, ashkenazy, alexeev, zhukov)
all_recordings <- bind_rows(pianists) %>%
    mutate(period = replace(sonata, sonata < 11, "Late")) %>%
    mutate(period = replace(period, sonata < 6, "Middle")) %>%
    mutate(period = replace(period, sonata < 4, "Early")) %>%
    mutate(period = factor(period, levels=c("Early", "Middle", "Late")))
```

```{r functions_chromagram, include=FALSE}
chroma_preprocessing <- function(sonata) {
  sonata <- sonata |>
  select(segments) |>
  unnest(segments) |>
  select(start, duration, pitches)
}

chromagram <- function(sonata, chroma) {
  if (chroma) {
    plot <- ggplot(sonata,
         aes(x = start + duration / 2,
            width = duration,
            y = pitch_class,
            fill = value
            )
        )
  } else {
    plot <- ggplot(sonata,
         aes(x = start + duration / 2,
            width = duration,
            y = basis,
            fill = value
            )
        )
  }
  
  plot +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude") +
  theme_classic() +
  scale_fill_viridis_c() +
  scale_x_continuous(breaks=seq(0,2000,60)) +
  theme(axis.text.x = element_text(angle=-45))
}
```

```{r useful_constants}
sonata_names <- c("Sonata 5", "Sonata 6", "Sonata 7", "Sonata 8", "Sonata 9", "Sonata 10")

cols <- c("Early" = "#c2df23", "Middle" = "#1fa187", "Late" = "#440154")
pitch_classes <- c("C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B")
facet_colour <- theme(strip.background = element_rect(fill = "#47b59f"),
                      strip.text = element_text(colour = "#ffffff"))

minute_scalex <- scale_x_continuous(breaks=seq(0,2000,60))
minute_scaley <- scale_y_continuous(breaks=seq(0,2000,60))
```

### sonata 2_2

```{r display_plot_3_2}
tempogram_3_2 <- readRDS(file = "data/plots/tempogram_3_2.RDS")
tempogram_3_2
```

***
We can also attempt to analyse a recording's tempo by finding its most consistent frequency between onsets. The Spotify API does a lot of the heavy lifting by providing us with a recording's onsets. Those can be used to make a Fourier-based tempogram which shows us at what frequency onsets appear throughout the recording.

Some music is very suitable for these kinds of analyses, as well as music that is a little less suitable. Our corpus unfortunately falls under the latter. Scriabin's music is generally very free in expression and tempo, which was not uncommon for a late-romantic, or early modernist composer. It is therefore also not unexpected that performers play his music with a lot of rubato. You can see how the tempogram of the second movement of his third sonata is quite literally all over the place, which is in my opinion one of the more 'rhythmically stable' parts of his sonatas.

This is another problem apart from the natural use of rubato. The 'beat' in Scriabin's music, like that of some of his contemporaries, is often very obscure to begin with. His frequent use of different polyrhythm and triplets, quintuplets or even septuplets, all contribute to creating rhythmically complex passages.

### Identifying tempo

```{r tempogram_function}
plot_tempogram <- function(sonata) {  
  sonata %>%
  tempogram(window_size = 8, hop_size = 1, cyclic = TRUE) |>
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_raster() +
  scale_fill_viridis_c(guide = "none") +
  labs(x = "Time (s)", y = "Tempo (BPM)") +
  theme_classic()
}
```

```{r display_tempogram_10}
tempogram_10 <- readRDS(file = "data/plots/tempogram_10.RDS")
tempogram_10
```

***
This rhythmic complexity




### The style of Scriabin

There are many composers who have made a name for themselves when it comes to their contribution to the piano repertoire. One such composer is Alexander Scriabin. However, what seperates him from other composers of similar regard, is the way in which his musical language has developed throughout his life. The influence of Frederic Chopin and other romantic composers can clearly be discerned at the start of his carreer. In spite of that, his music would increasingly veer away from traditional harmony and tonality over the turn of the 20th century. Much like Arnold Schoenberg, he had developed a unique, modernist style of music that would influence many other 20th century composers.

One of my goals is to examine wether Scriabin's changing style could be accurately represented. This development is perhaps best reflected in Scriabin's 10 piano sonatas, which span the majority of his composing carreer. My corpus therefore consists of recordings of these sonatas by four pianists, namely Vladimir Ashkenazy, Maria Lettberg, Igor Zhukov and Dmitri Alexeev. These pieces, much like his other works, leave the performer with room for their own interpretation. So It would perhaps also be interesting to see in what capacity spotify could measure the difference between performers.

When considering tracks of particular interest, the 4th and 5th piano sonatas come to mind. The former being one of his first pieces to display a concrete change in style, and the later being one of the first stepts into truly new territory. Yet despite their differences they do both have a distinct touch of lightness that is in my opinion more difficult to find in his other sonatas. A further look into these pieces may yield intriguing results.

### Comparing the energy and valence for all sonatas

```{r Energy_valence}
all_recordings_mean_energy_valence <- all_recordings %>%
  group_by(pianist, period, sonata) %>%
  summarize(mean_energy = mean(energy),
            mean_valence = mean(valence),
            period = factor(period, levels=c("Early", "Middle", "Late")))

zhukov_mean_energy_valence <- all_recordings_mean_energy_valence %>%
  filter(pianist == "Igor Zhukov")

cols <- c("Early" = "#c2df23", "Middle" = "#1fa187", "Late" = "#440154")

zhukov_plot <- ggplot(zhukov_mean_energy_valence, aes(x = mean_energy, y = mean_valence, color= period)) +
  annotate("rect", xmin = 0.065, xmax = 0.15, ymin = 0.028, ymax = 0.038, alpha = .2) +
  geom_point() +
  scale_y_log10() +
  scale_x_log10() +
  # scale_color_grey(start = 0.75, end = 0) +
  labs(x="Energy", y="Valence", color="Period", title="Energy and Valence for Scriabin's 10 sonatas",
       subtitle="Igor Zhukov") +
  annotate(
    "text",
    x = 0.1, y = 0.04,
    label = "Scriabin's late sonatas",
    vjust = 1, size = 5, color = "grey40"
  ) +
  scale_color_manual(values = cols)

ggplotly(zhukov_plot) %>%
  layout(title = list(text = paste0("Energy and Valence for Scriabin's 10 sonatas <br> <sup>Igor Zhukov</sup>")))
```

***

This plot displays the valence and energy levels of the sonatas performed by Igor Zhukov, just as an example. If you focus on the valence feature, valence being a measure of positiveness, you might notice that while the differences accross sonatas are small, all the late sonatas seem to lay at a distinct valence level compared to the rest.

Those familiar with the music in question might not be suprised by this. These pieces are very representative of Scriabin's changing musical style, despite the fact that they are individually still unique. 


### The late sonatas contain similar valence levels accros all performers

```{r Energy_Valence_all}
energy_valence_plot <- ggplot(all_recordings_mean_energy_valence, aes(x = mean_energy, y = mean_valence, color= period)) +
  geom_point() +
  facet_wrap(~ pianist) +
  scale_y_log10() +
  scale_x_log10() +
  scale_color_manual(values = cols) +
  labs(x="Energy", y="Valence", color="Period", title="Energy and Valence for Scriabin's 10 sonatas",
       subtitle="The late sonatas have a distinctly low valence level.") +
  facet_colour

ggplotly(energy_valence_plot)
```

***

here you can see the previous results extend very well to other pianists and their recordings. While the energy and valence levels of the early and middle period of Scriabin's works vary quite a bit, the late sonatas all fall on the same range of valence, even across different performers.

At the same time however, the pieces show somewhat of a variance in energy levels across performers. This could perhaps reflect the natural room for interpretation of Scriabin's works, albeit this is hard to say from just this data.

### A piece's tempo can vary quite a bit accross pianists
```{r tempo_plot}
tempo_features <- all_recordings |>
  mutate(
    sections =
      map(
        sections,                                    # sections or segments
        summarise_at,
        vars(tempo, loudness, duration),             # features of interest
        list(section_mean = mean, section_sd = sd)   # aggregation functions
      )
  ) |>
  unnest(sections) |>
  mutate(duration_min = duration / 60,
    loudness = factor(loudness),
    sd_tempo = tempo_section_sd)

test <- tempo_features |>
  ggplot(
    aes(
      group = sonata,
      x = tempo,
      y = sd_tempo,
      colour = period,
      alpha = loudness
    )
  ) +
  geom_point(aes(size = duration_min)) +
  geom_rug() +
  #theme(panel.background = element_rect(fill = "#f5fff2",
  #                              colour = "#f5fff2")) +
  theme_minimal() +
  labs(
    x = "Mean Tempo (bpm)",
    y = "SD Tempo",
    colour = "Genre",
    size = "Duration (min)",
    alpha = "Volume (dBFS)",
    title = "Tempo analysis of the different performers"
  ) + 
  facet_wrap(~ pianist) +
  scale_color_manual(values = cols) +
  facet_colour

ggplotly_plot <- ggplotly(test)
```
```{r}
ggplotly_plot$x$layout$legend$title$text <- "Duration:    size<br>Loudness:  opacity<br>Period:"

for (i in 1:length(ggplotly_plot$x$data)) {
  if (grepl("Early", ggplotly_plot$x$data[[i]]$name, fixed = TRUE) == TRUE) {
    ggplotly_plot$x$data[[i]]$legendgroup <- "Early"
    ggplotly_plot$x$data[[i]]$name <- "Early"
    
    ggplotly_plot$x$data[[i]]$showlegend <- FALSE
    if (i == 21){
        ggplotly_plot$x$data[[i]]$showlegend <- TRUE
    }
  } else if (grepl("Middle", ggplotly_plot$x$data[[i]]$name, fixed = TRUE) == TRUE) {
    ggplotly_plot$x$data[[i]]$legendgroup <- "Middle"
    ggplotly_plot$x$data[[i]]$name <- "Middle"
    
    ggplotly_plot$x$data[[i]]$showlegend <- FALSE
    if (i == 48){
        ggplotly_plot$x$data[[i]]$showlegend <- TRUE
    }
  } else if (grepl("Late", ggplotly_plot$x$data[[i]]$name, fixed = TRUE) == TRUE) {
    ggplotly_plot$x$data[[i]]$legendgroup <- "Late"
    ggplotly_plot$x$data[[i]]$name <- "Late"
    

    ggplotly_plot$x$data[[i]]$showlegend <- FALSE
    if (i == 71){
        ggplotly_plot$x$data[[i]]$showlegend <- TRUE
    }
  }
  
}

ggplotly_plot
```


***
When comparing different performances of the same pieces, many differences are bound to pop up. Such is the nature of interpretation, you could say. Two variables that are relatively easy to compare and measure are loudness and tempo. How accurate Spotify's analysis actually is, remains difficult to determine, but it couldn't hurt to take a look, right?

As expected, different pianist show quite a different spread when it comes to their tempo and tempo variance throughout their recordings. Maria Lettberg's recordings seem to all be quite consistent, while Vladimir Ashkenazy takes a lot more liberty when it comes to tempo. Besides that, Igor Zhukov's recordings all seem to be consistently louder. This might also just be a result of the different recording processes.




### Spotify is not very certain about the late sonata's keys
```{r keys_sonatas}
all_recordings %>%
  mutate(key_name = factor(key_name, levels = pitch_classes)) %>%
  filter(sonata >= 5, 
         movement == 1) %>%
  ggplot(aes(alpha = key_confidence, x = key_name, fill = pianist)) +
  geom_bar() +
  scale_fill_viridis_d() +
  scale_alpha(range=c(0.15, 1)) +
  facet_wrap(~ factor(sonata, labels = sonata_names), nrow = 3) + 
  labs(title = "Spotify key analysis", y = "", fill = "pianist", alpha = "confidence") +
  scale_x_discrete("Key", drop=FALSE) +
  facet_colour
```

***
Taking a look at the later half of Scriabin's sonatas, it quickly becomes clear that Spotify has a harder time finding a key to stick with. Perhaps not unexpectedly so, since these pieces do not adhere to traditional tonality, as mentioned. While there might not be much of a point to trying to identify a key in these pieces, not to mention how Spotify's analysis is probably not the best fit for unconventional music in general, it's still interesting to see how it even fails to agree on a pitch across different recordings.

Perhaps different pianists might naturally bring forward different pitches throughout these kinds of pieces, consciously or not. Or perhaps this is a result of the recording process, where different equipment, studios and 'finishing touches' might alter the pitch content of a recording.

On top of that, the key confidence feature also shows that Spotify itself is aware of its uncertainty to some degree. I've mapped Spotify's key_confidence feature to the opacity value of each recording. Some of the recordings are noticeably more opaque than the rest, but it's difficult to tell what might have caused that other than the fact that these pieces are simply tonally ambiguous.


### How clearly does a chromagram show a sonata's key?

```{r early_sonatas_chromagram, include=FALSE}
ashkenazy_1_1 <- ashkenazy %>% filter(sonata == 3, movement == 1)
ashkenazy_1_2 <- ashkenazy %>% filter(sonata == 3, movement == 2)
ashkenazy_1_3 <- ashkenazy %>% filter(sonata == 3, movement == 3)
ashkenazy_1_4 <- ashkenazy %>% filter(sonata == 3, movement == 4)

ashkenazy_4_1 <- ashkenazy %>% filter(sonata == 4, movement == 1)
ashkenazy_4_2 <- ashkenazy %>% filter(sonata == 4, movement == 2)

early_chroma_comparison <- list(ashkenazy_1_1,
                          ashkenazy_1_2,
                          ashkenazy_1_3,
                          ashkenazy_1_4,
                          ashkenazy_4_1,
                          ashkenazy_4_2)

early_chroma_comparison <- lapply(early_chroma_comparison, chroma_preprocessing)

ashkenazy_1_1_chroma <- early_chroma_comparison[[1]] %>% mutate(movement = 1)
ashkenazy_1_2_chroma <- early_chroma_comparison[[2]] %>% mutate(movement = 2,
                                                         start = start + tail(ashkenazy_1_1_chroma, n=1)$start)
ashkenazy_1_3_chroma <- early_chroma_comparison[[3]] %>% mutate(movement = 3,
                                                          start = start + tail(ashkenazy_1_2_chroma, n=1)$start)
ashkenazy_1_4_chroma <- early_chroma_comparison[[4]] %>% mutate(movement = 4,
                                                          start = start + tail(ashkenazy_1_3_chroma, n=1)$start)


ashkenazy_4_1_chroma <- early_chroma_comparison[[3]] %>% mutate(movement = 1)
ashkenazy_4_2_chroma <- early_chroma_comparison[[4]] %>% mutate(movement = 2,
                                                          start = start + tail(ashkenazy_4_1_chroma, n=1)$start)

ashkenazy_2_pitches <- bind_rows(list(ashkenazy_1_1_chroma,
                                      ashkenazy_1_2_chroma,
                                      ashkenazy_1_3_chroma,
                                      ashkenazy_1_4_chroma
                                      )) %>%
    mutate(sonata = "Sonata 1")
  
ashkenazy_4_pitches <- bind_rows(list(ashkenazy_4_1_chroma,
                                      ashkenazy_4_2_chroma)) %>%
    mutate(sonata = "Sonata 4")
```

```{r Chromagram_3_4}
ashkenazy_2_chromagram <- ashkenazy_2_pitches |>
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) |>
  compmus_gather_chroma()

ashkenazy_4_chromagram <- ashkenazy_4_pitches |>
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) |>
  compmus_gather_chroma()

ashk_2_chromaplot <- chromagram(ashkenazy_2_chromagram, TRUE) +
    labs(title = "Chromagram of the 3rd sonata", subtitle = "Vladimir Ashkenazy") +
    geom_vline(xintercept = head(ashkenazy_1_2_chroma, n=1)$start, colour = "#c2abab", size = 0.8) +
    geom_vline(xintercept = head(ashkenazy_1_3_chroma, n=1)$start, colour = "#c2abab", size = 0.8) +
    geom_vline(xintercept = head(ashkenazy_1_4_chroma, n=1)$start, colour = "#c2abab", size = 0.8)

ashk_4_chromaplot <- chromagram(ashkenazy_4_chromagram, TRUE) +
    labs(title = "Chromagram of the 4th sonata", subtitle = "Vladimir Ashkenazy") +
    geom_vline(xintercept = head(ashkenazy_4_2_chroma, n=1)$start, colour = "#c2abab", size = 0.8)

ashk_2_4_chromaplot <- list(ashk_2_chromaplot, ashk_4_chromaplot)

plot_grid(plotlist = ashk_2_4_chromaplot, ncol = 1)
```

***
--OLD TEXT--
Throughout Scriabin's carreer as a composer, you can quite clearly hear how his music starts getting more and more tonally ambiguous. Even to the point where it might not make much sense to discuss it in terms of tonality.

Take the following chromagrams of the 4th and 5th sonata for example. It is not far fetched to say that Scriabin's music has changed the most between these pieces. As a result, you can, albeit without the most confidence, observe how this piece is in F#. The 5th sonata on the other hand does not display display a clear tonic like the previous one does, which makes sense upon giving it a listen.
--OLD TEXT--

### Tonality is identifyable in early works...
```{r chord_masks, include=FALSE}
circshift <- function(v, n) {
  if (n == 0) v else c(tail(v, n), head(v, -n))
}

#      C     C#    D     Eb    E     F     F#    G     Ab    A     Bb    B
major_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    0,    0)
minor_chord <-
  c(   1,    0,    0,    1,    0,    0,    0,    1,    0,    0,    0,    0)
seventh_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    1,    0)

major_key <-
  c(6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88)
minor_key <-
  c(6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17)

augmented_scale <-
  c(6, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1)

prometheus_scale <-
  c(6, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0)

octatonic_scale <-
  c(6, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0)

octatonic_scale2 <-
  c(6, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1)

chord_templates <-
  tribble(
    ~name, ~template,
    "Gb:7", circshift(seventh_chord, 6),
    "Gb:maj", circshift(major_chord, 6),
    "Bb:min", circshift(minor_chord, 10),
    "Db:maj", circshift(major_chord, 1),
    "F:min", circshift(minor_chord, 5),
    "Ab:7", circshift(seventh_chord, 8),
    "Ab:maj", circshift(major_chord, 8),
    "C:min", circshift(minor_chord, 0),
    "Eb:7", circshift(seventh_chord, 3),
    "Eb:maj", circshift(major_chord, 3),
    "G:min", circshift(minor_chord, 7),
    "Bb:7", circshift(seventh_chord, 10),
    "Bb:maj", circshift(major_chord, 10),
    "D:min", circshift(minor_chord, 2),
    "F:7", circshift(seventh_chord, 5),
    "F:maj", circshift(major_chord, 5),
    "A:min", circshift(minor_chord, 9),
    "C:7", circshift(seventh_chord, 0),
    "C:maj", circshift(major_chord, 0),
    "E:min", circshift(minor_chord, 4),
    "G:7", circshift(seventh_chord, 7),
    "G:maj", circshift(major_chord, 7),
    "B:min", circshift(minor_chord, 11),
    "D:7", circshift(seventh_chord, 2),
    "D:maj", circshift(major_chord, 2),
    "F#:min", circshift(minor_chord, 6),
    "A:7", circshift(seventh_chord, 9),
    "A:maj", circshift(major_chord, 9),
    "C#:min", circshift(minor_chord, 1),
    "E:7", circshift(seventh_chord, 4),
    "E:maj", circshift(major_chord, 4),
    "G#:min", circshift(minor_chord, 8),
    "B:7", circshift(seventh_chord, 11),
    "B:maj", circshift(major_chord, 11),
    "D#:min", circshift(minor_chord, 3)
  )

key_templates <-
  tribble(
    ~name, ~template,
    "Gb:maj", circshift(major_key, 6),
    "Bb:min", circshift(minor_key, 10),
    "Db:maj", circshift(major_key, 1),
    "F:min", circshift(minor_key, 5),
    "Ab:maj", circshift(major_key, 8),
    "C:min", circshift(minor_key, 0),
    "Eb:maj", circshift(major_key, 3),
    "G:min", circshift(minor_key, 7),
    "Bb:maj", circshift(major_key, 10),
    "D:min", circshift(minor_key, 2),
    "F:maj", circshift(major_key, 5),
    "A:min", circshift(minor_key, 9),
    "C:maj", circshift(major_key, 0),
    "E:min", circshift(minor_key, 4),
    "G:maj", circshift(major_key, 7),
    "B:min", circshift(minor_key, 11),
    "D:maj", circshift(major_key, 2),
    "F#:min", circshift(minor_key, 6),
    "A:maj", circshift(major_key, 9),
    "C#:min", circshift(minor_key, 1),
    "E:maj", circshift(major_key, 4),
    "G#:min", circshift(minor_key, 8),
    "B:maj", circshift(major_key, 11),
    "D#:min", circshift(minor_key, 3)
  )
c_o_5 <-
  list("Gb", "Dd", "Ab", "Eb", "Bb", "F", "C", "G", "D", "A", "E", "B")

augmented_keys <-
  tribble(~name, ~template,
          "0", circshift(augmented_scale, 6))

prometheus_keys <-
  tribble(~name, ~template,
          paste("mystic", c_o_5[1]), circshift(prometheus_scale, 6))

octatonic_keys <-
  tribble(~name, ~template,
          # paste("octatonic 1", c_o_5[1]), circshift(octatonic_scale, 6),
          paste("octatonic", c_o_5[1]), circshift(octatonic_scale2, 6))

p_n_o <- bind_rows(prometheus_keys, octatonic_keys)

for (i in 2:12) {
  j <- (6 + 7 * (i-1)) %% 12
  key_a <-
  tribble(~name, ~template,
          c_o_5[[i]], circshift(augmented_scale, j))
  
  augmented_keys <- bind_rows(augmented_keys, key_a)
  
  key_p <-
  tribble(~name, ~template,
          paste("mystic", c_o_5[i]), circshift(prometheus_scale, j))
  
  prometheus_keys <- bind_rows(prometheus_keys, key_p)
  
  key_01 <-
  tribble(~name, ~template,
          paste("octatonic 1", c_o_5[i]), circshift(octatonic_scale, j))

  key_02 <-
  tribble(~name, ~template,
          paste("octatonic", c_o_5[i]), circshift(octatonic_scale2, j))
  
  octatonic_keys <- bind_rows(octatonic_keys,
                              #key_01,
                              key_02)
  
  p_n_o <- bind_rows(p_n_o, key_p, key_01, key_02)
}
```

```{r key_chord_functions}
chord_pitches <- function(sonata) {
  sonata <- sonata |>
  compmus_align(bars, segments) |>
  select(bars) |>
  unnest(bars) |>
  mutate(group = row_number() %/% 4) |>
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "rms", norm = "euclidean"
      )
  ) %>%
  group_by(group) %>%
  mutate(pitches = list(colMeans(do.call(rbind, pitches))))
}

plot_key_chords <- function(sonata, template) {
  templates <- list(octatonic = octatonic_keys,
                 normal_key = key_templates)
  
  sonata |> 
  compmus_match_pitch_template(
    templates[[pmatch(template, names(templates))]],         # Change to chord_templates if descired
    method = "angular",  # Try different distance metrics
    norm = "euclidean"     # Try different norms
  ) |>
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_fill_viridis_c(guide = "none",
                       direction = -1,
                       trans = 'log'
    ) +
  theme_classic() +
  labs(x = "Time (s)", y = "") +
  scale_x_continuous(breaks=seq(0,2000,60))
}
```

```{r load_key_est_sonatas}
zhukov_2_1 <- zhukov %>%
  filter(sonata == 2,
         movement == 1) %>%
  chord_pitches()

zhukov_9_1 <- zhukov %>%
  filter(sonata == 9) %>%
  chord_pitches()
```

```{r plot_key_est_s2}
key_2_1 <- plot_key_chords(zhukov_2_1, "normal_key") +
  labs(title = "Keygram | sonata 2, mvt. 1", subtitle = "Igor Zhukov") +
  geom_vline(xintercept = 235, colour = "#c2abab", size = 0.8) +
  geom_vline(xintercept = 320, colour = "#c2abab", size = 0.8)
key_2_1
```

***
```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/0zKZR4PiuC60TpDRo9VWWZ?utm_source=generator&theme=0" width="100%" height="352" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy" data-external="1"></iframe>
```

We can use a recording's pitch content to try and estimate its key and which chords appear in it. An example of this can be seen here for the first movement of the second sonata in G# minor. This piece can quite easily be described in sonata form, with the exposition starting in G# minor as expected, briefly going to D# minor before largely remaining in B major.

The development section continues in B major, before quickly and briefly shifting to D major, G minor, C minor, F minor and eventually leads back to G# minor. The recapitulation continues on in G# minor, before quickly modulating to the relative E major and remaining there until the end of the movement.

These key changes are reflected quite well in the keygram, although it certainly helps to know them beforehand.


### What about the later sonatas?
```{r plot_key_est_s9}
key_9_1 <- plot_key_chords(zhukov_9_1, "octatonic") +
  labs(title = "Keygram | sonata 9", subtitle = "Igor Zhukov")
key_9_1
```

***
```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/70LZoLXVyBcbaMKDaSNvAn?utm_source=generator&theme=0" width="100%" height="352" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy" data-external="1"></iframe>
```

There's a lot that can be said about Scriabin's harmonic language. One important aspect of his later works is how, to a fair extent, it's based on unique scales and chords such as the [octatonic scale](https://en.wikipedia.org/wiki/Octatonic_scale) or the ['mystic' chord](https://en.wikipedia.org/wiki/Mystic_chord). I've tried to create a mask of one of the organizations of the octatonic scale for each pitch class to see if it may yield interesting results for the 9th sonata.

It is admittedly quite hard to say whether these results hold any weight. The plot does seem to consistently mark certain sections to use a certain octatonic scale. I've looked through the score and confirmed that some of these sections do indeed use the pitches of these octatonic scales. However, the same cannot be said for the other sonatas, some of which also do make use of this scale. There's also the fact that my mask only makes a distinction with the key's 'starting' pitch, the pitches within the octatonic scale and the rest of the pitches. The masks is very simple and likely does not properly convey to which degree each pitch supports an octatonic key.


### From the 5th sonata, each sonata's key starts getting more ambiguous

```{r load_ashkenazy, include=FALSE, cache=TRUE}
ashkenazy_5_1 <- ashkenazy %>% filter(sonata == 5, movement == 1)
ashkenazy_6_1 <- ashkenazy %>% filter(sonata == 8, movement == 1)

late_chroma_comp <- list(ashkenazy_5_1,
                         ashkenazy_6_1)


late_chroma_comp <- lapply(late_chroma_comp, chroma_preprocessing)

ashkenazy_5_1_chroma <- late_chroma_comp[[1]] %>% mutate(movement = 1)
ashkenazy_6_1_chroma <- late_chroma_comp[[2]] %>% mutate(movement = 1)


ashkenazy_5_chromagram <- ashkenazy_5_1_chroma |>
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) |>
  compmus_gather_chroma()

ashkenazy_6_chromagram <- ashkenazy_6_1_chroma |>
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) |>
  compmus_gather_chroma()


ashk_5_chromaplot <- chromagram(ashkenazy_5_chromagram, TRUE) +
    labs(title = "Chromagram of the 5th sonata", subtitle = "Vladimir Ashkenazy")

ashk_6_chromaplot <- chromagram(ashkenazy_6_chromagram, TRUE) +
    labs(title = "Chromagram of the 8th sonata", subtitle = "Vladimir Ashkenazy")

chroma_ashkenazy <- list(ashk_5_chromaplot, ashk_6_chromaplot)

```

```{r Chromagram_ashkenazy}
plot_grid(plotlist = chroma_ashkenazy, ncol = 1)
```

***
-- ADD TEXT --


### Aligning different performances

```{r DTW, cache=TRUE}
lettberg_7 <- lettberg %>% filter(sonata == 7, movement == 1)
ashkenazy_7 <- ashkenazy %>% filter(sonata == 7, movement == 1)

DTW_recordings <- lapply(list(lettberg_7, ashkenazy_7), chroma_preprocessing)

DTW_plot <- compmus_long_distance(
  DTW_recordings[[1]] |> mutate(pitches = map(pitches, compmus_normalise, "manhattan")),
  DTW_recordings[[2]] |> mutate(pitches = map(pitches, compmus_normalise, "manhattan")),
  feature = pitches,
  method = "aitchison"
) |>
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_equal() +
  labs(x = "Maria Lettberg", y = "Vladimir Ashkenazy", title = "Sonata 7") +
  theme_minimal() +
  scale_fill_viridis_c(guide = NULL) +
  minute_scalex +
  minute_scaley +
  theme(axis.text.x = element_text(angle=-45))
```

```{r dtw_plot, cache=TRUE}
DTW_plot
  #geom_segment(aes(x = 0, y = 0, xend = 749, yend = 646), colour = "#c2abab", size = 0.4, alpha = 0.2)
```

***
```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/7EYRKteYYguJuCMvH1MA2e?utm_source=generator&theme=0" width="100%" height="352" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy" data-external="1"></iframe>
```

Chromagrams can also be used to align different performances of the same music. To put it shortly, this is done by matching similar segments of the chromagrams.

### It is difficult to gather much information out of timbre

```{r self_similarity_recordings, include=FALSE}
lettberg_1_1 <- lettberg %>% filter(sonata == 1, movement == 1)
lettberg_8_1 <- lettberg %>% filter(sonata == 8, movement == 1)
```

```{r functions_timbre_selfsim, include=FALSE}
chroma_and_timbre <- function(sonata) {
  sonata <- sonata |>
  compmus_align(bars, segments) |>                     # Change `bars`
  select(bars) |>                                      #   in all three
  unnest(bars) |>                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  ) |>
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "rms", norm = "euclidean"             # Change summary & norm.
      )
  )
}

self_similarity <- function(sonata, chroma) {
  if (chroma) {
    plot <- sonata |>
      compmus_self_similarity(pitches, "cosine") 
  } else {
    plot <- sonata |>
      compmus_self_similarity(timbre, "cosine") 
  }
  
  plot |> 
    ggplot(
      aes(
        x = xstart + xduration / 2,
        width = xduration,
        y = ystart + yduration / 2,
        height = yduration,
        fill = d
      )
    ) +
    geom_tile() +
    coord_fixed() +
    scale_fill_viridis_c(guide = "none") +
    theme_classic() +
    labs(x = "", y = "") +
    scale_x_continuous(breaks=seq(0,2000,60)) +
    scale_y_continuous(breaks=seq(0,2000,60)) +
    theme(axis.text.x = element_text(angle=-45))
}

compmus_test <- function(dat, feature, method = "euclidean") {
  feature <- enquo(feature)
  compmus_test2(dat, dat, !!feature, method)
}

compmus_test2 <- function(xdat, ydat, feature, method = "euclidean") {
  feature <- enquo(feature)

  ## Supported functions

  manhattan <- function(x, y) sum(abs(x - y))
  euclidean <- function(x, y) sqrt(sum((x - y)^2))
  chebyshev <- function(x, y) max(abs(x - y))
  pearson <- function(x, y) 1 - cor(x, y)
  cosine <- function(x, y) {
    1 - sum(compmus_normalise(x, "euc") * compmus_normalise(y, "euc"))
  }
  angular <- function(x, y) 2 * acos(1 - cosine(x, y)) / pi
  aitchison <- function(x, y) {
    euclidean(compmus_normalise(x, "clr"), compmus_normalise(y, "clr"))
  }

  ## Method aliases

  METHODS <-
    list(
      manhattan = manhattan,
      cityblock = manhattan,
      taxicab = manhattan,
      L1 = manhattan,
      totvar = manhattan,
      euclidean = euclidean,
      L2 = euclidean,
      chebyshev = chebyshev,
      maximum = chebyshev,
      pearson = pearson,
      correlation = pearson,
      cosine = cosine,
      angular = angular,
      aitchison = aitchison
    )

  ## Function selection

  if (!is.na(i <- pmatch(method, names(METHODS)))) {
    dplyr::full_join(
      xdat %>%
        dplyr::select(xstart = start, xduration = duration, x = !!feature),
      ydat %>%
        dplyr::select(ystart = start, yduration = duration, y = !!feature),
      by = character()
    ) %>%
      dplyr::transmute(
        xstart, xduration,
        ystart, yduration,
        timb = purrr::map2_dbl(x, y, METHODS[[i]])
      )
  } else {
    stop("The method name is ambiguous or the method is unsupported.")
  }
}
```

```{r sonata_1_8_preproces}
timbre_analysis <- list(lettberg_1_1,
                        lettberg_8_1)

timbre_analysis <- lapply(timbre_analysis, chroma_and_timbre)
```

```{r cepstogram_1_8}
sonata_1 <- timbre_analysis[[1]]
sonata_8 <- timbre_analysis[[2]]


cep_1 <- sonata_1 |>
  compmus_gather_timbre() |>
  chromagram(chroma = FALSE) +
    geom_vline(xintercept = 151, colour = "#c2abab", size = 0.8) +
    geom_vline(xintercept = 299, colour = "#c2abab", size = 0.8) +
    labs(title = "Cepstrogram of the 1st sonata, mvt. 1", subtitle = "Maria Lettberg")


cep_8 <- sonata_8 |>
  compmus_gather_timbre() |>
  chromagram(chroma = FALSE) +
  labs(title = "Cepstrogram of the 8th sonata", subtitle = "Maria Lettberg") +
  geom_vline(xintercept = 140, colour = "#c2abab", size = 0.8)


plot_grid(plotlist = list(cep_1, cep_8), ncol = 1)
```

***
Similarly to the chromagrams, spotify also allows us to analyse the timbre content of the pieces, referred to as Cepstrograms.
However, solo piano works don't always lend themselves to this type of analysis, since you are generally limited in the kinds of timbres
you can create with just a piano, unless you start employing extended techniques like in [George Crumb's](https://youtu.be/pIEUS0-DDcs) case for instance. Regardless, there are instances where a pieces's eccentricities are reflected in its cepstrogram.

Consider a sonata's structure for example. One defining aspect of the sonata is how its first movement is composed in sonata form. Although like most musical conventions, composers have been straying from this practice over time, including Scriabin. Despite that, his first sonata does display a strong semblance of sonata form. When looking at the cepstrogram, you can make out how the exposition section is repeated once in the sonata's beginning.

Structural details like this are hard to find in his other sonatas, especially when only looking at pitch and timbre. It is quite tough to define an overarching structure in his 8th sonata for instance. Nevertheless, you can clearly see the first 2 minutes being distinct from the rest of the piece. Upon giving this sonata a listen, you'll notice that this section is noticeably unnerving yet tranquil.

### The structure of Scriabin's sonatas is not always easy to define

```{r self_sim_1}
selfsim_chroma_1 <- self_similarity(sonata_1, chroma=TRUE) +
  labs(title = "Pitch | Sonata No. 1, mvt. 1", subtitle = "Maria Lettberg")
selfsim_timbre_1 <- self_similarity(sonata_1, chroma=FALSE) +
  labs(title = "Timbre | Sonata No. 1, mvt. 1", subtitle = "Maria Lettberg")

plot_grid(plotlist = list(selfsim_chroma_1, selfsim_timbre_1)) + labs(title = "Self similarity matrices")
```

***
```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/0GAbhHPecfDF8LBYTwNmQO?utm_source=generator&theme=0" width="100%" height="352" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy" data-external="1"></iframe>
```

These plots display the pitch and timbre-based self-similarity within Scriabin's first sonata. While the Timbre matrix does not seem to divulge much, since the overall timbre of the piece does not vary much, you can still make out how there's one bar after around 150 seconds where there's a large pause. Other than that, the plot does not tell us much.

The pitch-based self-similarity matrix on the other hand does clearly display the repetition of the sonata's exposition. As seen in how there's a dark blue line parallel to the diagonal of the matrix, indicating that two different sections of the piece overlap. The development and recapitulation are a bit harder to make out. However if you look closely, you can just barely see a very short dark blue diagonal line starting at 420 seconds on the x axis. This line is very short since the recapitulation almost immediately modulates to a different key.

### Self-similarity matrices help very little with the later sonatas

```{r self_sim_8}
selfsim_chroma_8 <- self_similarity(sonata_8, chroma=TRUE) +
  labs(title = "Pitch | Sonata No. 8", subtitle = "Maria Lettberg")

selfsim_timbre_8 <- self_similarity(sonata_8, chroma=FALSE) +
  labs(title = "Timbre | Sonata No. 8", subtitle = "Maria Lettberg")

plot_grid(plotlist = list(selfsim_chroma_8, selfsim_timbre_8))
```

***
```{=html}
<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/7GfFMPRWzHVQ2siD16SIgZ?utm_source=generator&theme=0" width="100%" height="352" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy" data-external="1"></iframe>
```

As Scriabin started breaking away from conventional late-romanticism, he also began applying structure to his pieces in a different way. Rather than repetition, Scriabin utilizes many different motifs that he transforms, combines, transposes and puts into different contexts. What then defines the different sections of these pieces is how these motifs are applied. Two sections might be related through a motif appearing in a similar context, despite being modulated, in a different register or altered. This makes it very difficult to find any meaning these self-similarity matrices, as the sonatas' structures are not defined by either pitch nor timbre. Not to mention how there's is little to go off of on timbre. Let alone how these pieces' actual structures are up to debate.

When specifically looking at the matrices of the eight sonata, we can once more see instances of prolonged silence in the timbre matrix. We can also once again clearly see the distinction of the <i>introduction</i> compared to the rest of the piece. Truthfully, once you start to thoroughly analyse this piece, you'll find that it does follow some semblance of sonata form [as seen here](http://www.scriabin-association.com/skryabins-eighth-sonata-composers-last-word-sonata-form-simon-nicholls/).

However it does not really show in either matrix, as expected. You can vaguely make out how the piece cycles through different harmonic material in the pitch matrix, although this is by no means a strong indication of its structure. For instance, what one could consider the <i>exposition</i> and <i>recapitulation</i> of this sonata, begin at 150 seconds and 550 seconds respectively, but this is not reflected in either plot. While these sections may be musically similar, they are harmonically quite different and the timbre matrix is generally only helpful in identifying silent parts in the recording. One small moment of silence can actually be seen preceding the aforementioned recapitulation at 550 seconds.
